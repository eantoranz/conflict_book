% copyright 2020 Edmundo Carmona Antoranz
% Released under the terms of Creative Commons Attribution-ShareAlike 4.0 International Public License

\section{Los conflictos son una moneda de 3 caras}
\label{diff3}

Hagamos nuestro primer ejemplo de un proyeco {\it real}. En este caso, \hyperref[git_repo]{del propio git}.

\subsection{Ejemplo 3 - un conflicto de git}
\label{example_03}

Del \hyperref[git_repo]{repo de git}, hagan checkout de la revision {\bf 80648bb3f2} and mezclen {\bf 20a5fd881a}
\footnote{estos son los padres de la revisión {\bf 0df82d99da}}. Deben quedar con un conflicto en {\bf pack-bitmap.c}:
% FIXME might need to make it a little narrower
\begin{lstlisting}[style=c_style, firstnumber=671, caption={\bf Ejemplo 3} - Conflicto en {\bf pack-bitmap.c}]
	struct bitmap *objects = bitmap_git->result;

<<<<<<< HEAD
	ewah_iterator_init(&it, type_filter);
=======
	if (bitmap_git->reuse_objects == bitmap_git->pack->num_objects)
		return;

	init_type_iterator(&it, bitmap_git, object_type);
>>>>>>> 20a5fd881a

	for (i = 0; i < objects->word_alloc &&
\end{lstlisting}

Los escucho. Debemos mantener {\bf todas las líneas}? Cual bloque debe venir primero? {\bf HEAD} o
{\bf la otra rama}? Quizás la llamada a {\bf ewah\_iterator\_init()} debería ser colocada entre el condicional y
la llamada a {\bf init\_type\_iterator()} de {\bf la otra rama}? Quizás todas las líneas deberían ser borradas?
Quizás solo nos debamos quedar con {\it solo una parte}?

Todos esos escenarios son posibles? Si, todos son {\it posibles}. Y todos son {\bf\it correctos}? Ah, {\bf no}. Dado que ellos
terminan siendo diferentes con relación a lo que el código {\bf hace}, no todos pueden ser correctos. Pero entonces, esto de
resolver conflictos se trata de un juego de adivinanzas? Una lotería? No, no hay necesidad de adivinar. Quizás en este punto
todavía no estén al tanto de ello pero lo que se necesita es un poco más de información. Información que, por cierto, no está
disponible en el conflicto como se muestra allí. Déjenme mostrarles algunos escenarios para que vean de lo que estoy hablando.

\subsubsection{Ejemplo 3 - Escenario 1}
Para los efectos de poder hacer la explicación, {\it assuman} que el archivo en {\bf en el ancestro común} \footnote{A grandes
rasgos, la última revisión que está presente en ambas ramas que se están mezclando} se ves así, alrededor de esas líneas:
\footnote{Este {\bf no} es el contenido real en {\bf el ancestro común}, por cierto. Solo deben {\bf asumir} que así sea.}

\begin{lstlisting}[style=c_style, firstnumber=671, caption={\bf Ejemplo 3} - Escenario 1 - código en {\bf el ancestro común}]
	struct bitmap *objects = bitmap_git->result;

	ewah_iterator_init(&it, type_filter);
	if (bitmap_git->reuse_objects == bitmap_git->pack->num_objects)
		return;

	init_type_iterator(&it, bitmap_git, object_type);

	for (i = 0; i < objects->word_alloc &&
\end{lstlisting}

Si eso fuera así, eso quiere decir que, {\it basados en el conflicto}, cada una de las ramas removió {\it una sección del
código original}. {\bf HEAD} removió el condicional de la línea 674 y la llamada a {\bf init\_type\_iterator()}. {\bf La
otra rama} removió la llamada a {\bf ewah\_iterator\_init()}.

Entonces la resolución del conflicto sería esta::
\begin{lstlisting}[style=c_style, firstnumber=671, caption={\bf Ejemplo 3} - Escenario 1 - resolución del conflicto]
	struct bitmap *objects = bitmap_git->result;

	for (i = 0; i < objects->word_alloc &&
\end{lstlisting}

\subsubsection{Ejemplo 3 - Escenario 2}
Ahora asuman que {\bf el ancestro común} se ve así:

\begin{lstlisting}[style=c_style, firstnumber=671, caption={\bf Ejemplo 3} - Escenario 2 - código en {\bf el ancestro común}]
	struct bitmap *objects = bitmap_git->result;

	ewah_iterator_init(&it, type_filter);
	if (bitmap_git->reuse_objects == bitmap_git->pack->num_objects)
		return;

	for (i = 0; i < objects->word_alloc &&
\end{lstlisting}

En este caso, , {\bf HEAD} removió el condicional que arranca en la linea 674, {\bf la otra rama} reemplaza la llamada a
{\bf ewah\_iterator\_init()} por una llamada a {\bf init\_type\_iterator()}. Eso apunta a tener esto como resolución de
conflicto:

\begin{lstlisting}[style=c_style, firstnumber=671, caption={\bf Ejemplo 3} - Escenario 2 - Resolución del conflicto]
	struct bitmap *objects = bitmap_git->result;

	init_type_iterator(&it, bitmap_git, object_type);

	for (i = 0; i < objects->word_alloc &&
\end{lstlisting}

\subsubsection{Ejemplo 3 - Escenario 3}
Finalmente, asuman que {\bf el ancestro común} se ve así:

\begin{lstlisting}[style=c_style, firstnumber=671, caption={\bf Ejemplo 3} - Escenario 3 - código en {\bf el ancestro común}]
	struct bitmap *objects = bitmap_git->result;

	if (bitmap_git->reuse_objects == bitmap_git->pack->num_objects)
		return;

	for (i = 0; i < objects->word_alloc &&
\end{lstlisting}

En este escenario, {\bf HEAD} removió el condicional que arranca en la línea 673 y agrega una llamada a {\bf ewah\_iterator\_init()}.
En {\bf la otra rama} se mantiene el condicional pero se agrega una llamada a {\bf init\_type\_iterator()}. Esto significa
{\bf otra resolución}.  Debemos remover el condicional y mantener las dos llamadas.... pero cual debería venir primero? Esa es
una muy buena pregunta y es algo que el código solo no nos puede responder. Tendríamos que requerir más conocimiento de fondo del
código en cuestión para poderlo resolver de forma apropiada, o incluso tener que revisar los requerimientos que se utilizaron para
incluir cada llamada.\footnote{Eso puede requerir bastante tiempo, cierto?} Asumamos, solo para poder avanzar con el escenario que
ya sabemos que la llamada a {\bf init\_type\_iterator()} se debe hacer antes de la llamada a {\bf ewah\_iterator\_init()}. Entonces
la resolución del conflicto sería esta:

\begin{lstlisting}[style=c_style, firstnumber=671, caption={\bf Ejemplo 3} - Escenario 3 - Resolución del conflicto]
	struct bitmap *objects = bitmap_git->result;

	init_type_iterator(&it, bitmap_git, object_type);

	ewah_iterator_init(&it, type_filter);

	for (i = 0; i < objects->word_alloc &&
\end{lstlisting}

Así que tenemos 3 escenarios diferentes para {\it el mismo conflicto}. Y cada escenario requirió una resolución diferente.
En este punto lo que quiero que descubran es {\bf la cruda realidad}: {\bf el ancestro común} \footnote{junto con el conflicto
en sí mismo} dirige la resolución del conflicto. Si {\bf no} consideran {\bf el ancestro común}, estarían.... cual sería la mejor
palabra para describirlo? Ah, si! {\bf Adivinando!} Y no me importa cuan educada su adivinanza sea (en términos del conocimiento
del código involucrado). Tendrían que tener una memoria que supere a la provista por git para recordar como era el código en el
pasado para que deje de llamarlo de esa forma.

Habiendo aclarado ese punto, continuemos con el ejemplo actual. Como se veía {\bf el ancestro común} en este caso? Descubrirlo es un
proceso que requiere de más de u paso así que comencemos:

\subsubsection{Ejemplo 3 - Resolviendo el conflicto de verdad}
Primero lo primero. Cual es el ancestro común?

\begin{lstlisting}[style=console_style, caption={\bf Ejemplo 3} - Averiguando {\bf el ancestro común}]
$ git merge-base HEAD MERGE_HEAD
d0654dc308b0ba76dd8ed7bbb33c8d8f7aacd783
\end{lstlisting}

{\bf El ancestro común} es la revisión {\bf d0654dc308b0ba76dd8ed7bbb33c8d8f7aacd783}. En esa revisión, el archivo
se llama igual? {\bf Esperemos que sí!}. El contenido cambió mucho? Quiás se {\it agregaron} o {\it eliminaron} algunas líneas
antes del código relativo al bloque en conflicto? Esperemos que no sea el caso!\footnote{No se a ustedes, pero a mí no me gusta
cruzar tanto los dedos a la hora de sentarme a hacer desarrollo... por lo menos, no tan seguido}. Hagamos un intento:

\begin{lstlisting}[style=console_style, basicstyle=\small, caption={\bf Ejemplo 3} - verificando {\bf el ancestro común}]
$ git blame -s -L 671,681 d0654dc30 -- pack-bitmap.c
fff42755efc 671)        while (roots) {
fff42755efc 672)                struct object *object = roots->item;
fff42755efc 673)                roots = roots->next;
fff42755efc 674) 
3ae5fa0768f 675)                if (find_pack_entry_one(object->oid.hash, bitmap_git->pack) > 0)
fff42755efc 676)                        return 1;
fff42755efc 677)        }
fff42755efc 678) 
fff42755efc 679)        return 0;
fff42755efc 680) }
fff42755efc 681)
\end{lstlisting}

{\bf Ups!} Se nos acabó la suerte.\footnote{Se sienten con suerte? NO se sienten a hacer desarrollo, por favor. Las vegas suena como un
sitio más apropiado} El archivo no ha sido renombrado ({\bf que bien!}) pero su contenido sí cambió ({\bf que mal!}) y por lo 
tanto la sección que tenemos que mirar no está en la misma posición. Luego de mirar el archivo un rato, nos damos cuenta de que
lo que nos interesa está unas 40 líneas más arriba en el archivo:

\begin{lstlisting}[style=console_style, basicstyle=\small, caption={\bf Ejemplo 3} - verificando {\bf el ancestro común}... de nuevo]
$ git blame -s -L 631,638 d0654dc30 -- pack-bitmap.c
3ae5fa0768f 631)        struct bitmap *objects = bitmap_git->result;
3ae5fa0768f 632) 
3ae5fa0768f 633)        if (bitmap_git->reuse_objects == bitmap_git->pack->num_objects)
fff42755efc 634)                return;
fff42755efc 635) 
fff42755efc 636)        ewah_iterator_init(&it, type_filter);
fff42755efc 637) 
fff42755efc 638)        while (i < objects->word_alloc && ewah_iterator_next(&filter, &it)) {
\end{lstlisting}

Y {\it ahora} podemos comparar lo que hizo cada rama. En {\bf HEAD}, se {\it removió} el condicional que comienza en
la línea 633.\footnote{Línea 633 del arhivo en {\bf el ancestro común}}. En {\bf la otra rama}, se {\it removió} la llamada
a {\bf ewah\_iterator\_init()} y se agregó la llamada a {\bf init\_type\_iterator()}. Lo que significa que en nuestra resolución
del conflicto solo debemos mantener la llamada a {\bf init\_type\_iterator()} ya que las otras partes del código
original pasaron a mejor vida:

\begin{lstlisting}[style=c_style, firstnumber=671, caption={\bf Ejemplo 3} - resolucin final]
	struct bitmap *objects = bitmap_git->result;

	init_type_iterator(&it, bitmap_git, object_type);

	for (i = 0; i < objects->word_alloc &&
\end{lstlisting}

Y al comparar esto con la revisión {\bf 0df82d99da}, no se deberían ver diferencias significativas.
\footnote{Una diferencia de formato? Está bien. Este trabajo no se va a publicar, cierto?}

En este punto espero que hayan comprendido por qué es tan importante considerer {\bf el ancestro común} en un conflicto.
Como dije antes, al no considerar el ancestro común están, en el mejor de los casos, {\it adivinando}... en el peor de los casos,
cometiendo {\it un desastre}. Estoy de acuerdo en que es {\it bastante trabajo} si vamos a hacer este proceso cada vez que tenemos
un conflicto.
\begin{itemize}
	\item Averiguar {\bf el acestro común}
	\item Esperar que el archivo no se haya renombrado
	\item Esperar que el archivo no haya cambiado tanto para encontrar el bloque que nos interesa
\end{itemize}

Qué sucede si el archivo fue renombrado? Podemos averiguar el nombre original fácilmente?

Antes de que quemen (o borren) el archivo en medio de la frustración, déjenme mostrarles un pequeño {\it truco} que git tiene debajo de la
manga. Git les puede mostrar el contenido del {\bf ancestro común} sin trabajo adicional de su parte. Al configurar.{\bf merge.conflictStyle}
para que tenga el valor {\bf diff3} \footnote{ Ejecuten {\bf git config merge.conflictStyle diff3}. Usen {\bf --global} si
quieren que aplique de forma global y no por-repo}, git les mostrará el código del ancestro común como una sección
más del conflicto. Déjenme mostrarles como se vería el conflicto que acabamos de analizar con esta opción:

\subsubsection{Example 3 - Solving the conflict for real with {\bf diff3}}
\begin{lstlisting}[style=c_style, firstnumber=671, caption={\bf Ejemplo 3} - conflicto con {\bf diff3} aplicado]
	struct bitmap *objects = bitmap_git->result;

<<<<<<< HEAD
	ewah_iterator_init(&it, type_filter);
||||||| d0654dc308
	if (bitmap_git->reuse_objects == bitmap_git->pack->num_objects)
		return;

	ewah_iterator_init(&it, type_filter);
=======
	if (bitmap_git->reuse_objects == bitmap_git->pack->num_objects)
		return;

	init_type_iterator(&it, bitmap_git, object_type);
>>>>>>> 20a5fd881a

	for (i = 0; i < objects->word_alloc &&
\end{lstlisting}

{\bf Ajá!} Ahora podemos ver {\bf el ancestro común} entre las secciones de cada rama. git también tiene la amabilidad de
indicarnos cual es la revisión del ancestro común. Y ahora podemos ver qué hizo cada rama.

Para resolver nuestro conflicto, comiencen a trabajar en la sección de {\bf HEAD}:
\begin{lstlisting}[style=c_style, firstnumber=673, caption={\bf Ejemplo 3} - paso 1]
<<<<<<< HEAD
	ewah_iterator_init(&it, type_filter);
||||||| d0654dc308
\end{lstlisting}

Consideren como cambió el código {\bf desde el ancestro común hacia la otra rama}:

\begin{lstlisting}[style=c_style, firstnumber=675, caption={\bf Ejemplo 3} - Paso 2]
||||||| d0654dc308
	if (bitmap_git->reuse_objects == bitmap_git->pack->num_objects)
		return;

	ewah_iterator_init(&it, type_filter);
=======
	if (bitmap_git->reuse_objects == bitmap_git->pack->num_objects)
		return;

	init_type_iterator(&it, bitmap_git, object_type);
>>>>>>> 20a5fd881a
\end{lstlisting}

La llamada a {\bf ewah\_iterator\_init()} se reemplazó por una llamada a {\bf init\_type\_iterator()}. Replicamos
este cambio en {\bf HEAD}:

\begin{lstlisting}[style=c_style, firstnumber=673, caption={\bf Ejemplo 3} - Paso 3]
<<<<<<< HEAD
	init_type_iterator(&it, bitmap_git, object_type);
||||||| d0654dc308
\end{lstlisting}

Y ya podemos remover el resto del conflicto y los marcadores:

\begin{lstlisting}[style=c_style, firstnumber=671, caption={\bf example 3} - Done!]
	struct bitmap *objects = bitmap_git->result;

	init_type_iterator(&it, bitmap_git, object_type);

	for (i = 0; i < objects->word_alloc &&
\end{lstlisting}

Vieron? {\bf Sin complicaciones}.

Pero, en serio! Es {\it posible} sobrevivir resolver conflictos sin mirar {\bf el ancestro común}, cierto?
Pero {\bf por supuesto}! Igual que es posible desarrollar código sin hacer ningún tipo de pruebas unitarias, {\it me
explico}? No es que sea como el oxígeno o el agua. Pero ya les dije lo que es hacerlo sin mirar {\bf el ancestro común}:
Es {\bf adivinar}! Usar esta opción para mirar {\bf el ancestro común} es el tip más importante de este manual.

\subsection{Tips}
\begin{itemize}
	\item {\bf siempre} considerar el código de {\bf el ancestro común}.
	\item Configurar {\bf merge.conflicStyle} en {\bf diff3} para que lo muestre directamente en la sección del conflicto.
\end{itemize}

\subsection{Ejercicios}
\subsubsection{Ejercicio 3}
Del \hyperref[git_repo]{repo de git}, hacer checkout de la revisión {\bf fe870600fe} y mezclar {\bf 1bdca81641}
\footnote{Estos son los padres de la revisión {\bf f8cb64e3d4}}. Resuelvan ambos conflictos (hay 2 archivos con conflctos,
un conflicto en cada archivo). La solución está \hyperref[example_03]{aquí}.

