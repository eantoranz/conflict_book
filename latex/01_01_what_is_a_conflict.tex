% copyright 2020 Edmundo Carmona Antoranz
% Released under the terms of Creative Commons Attribution-ShareAlike 4.0 International Public License

\section{Qué es un conflicto?}

Un conflicto se presenta cundo hay dos direcciones diferentes en las que una sección de código ha sido modificado. Mientras las
modificaciones se mantengan separadas (digamos, en {\it ramas diferentes}) no habrá problema, pero al tratar de mezclarlas, git se detendrá
y pedirá ayuda para saber qué se debe hacer y terminar la operación.

\subsection{Ejemplo 0 - Un no-conflicto}
\label{example_00}

Permítanme presentarles uno de los scripts que vamos a utilizar (con algunas variaciones por el camino) como la {\it base} para
algunos de nuestros ejemplos.

\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 0} - ancestro común]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

Es un script python muy sencillo

Supongamos que dos desarrolladores comienzan a trabajar a partir de él para agregar un color diferente. El {\bf Desarrollador A}
produce esto:

\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 0} - Desarrollador A]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
          "red": "red tide",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

Se puede ver que se agregó el color rojo en la línea 7.

Y el {\bf Desarrollador B} produjo esto:
\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 0} - Desarrollador B]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "green": "green peas",
          "white": "white noise",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}
{\bf Developer B} added color green on line 6.

Se puede que se agregó el color verde en a línea 6.

La historia de las ramas en este punto se ve así::
\begin{lstlisting}[style=branch_history_style, caption={\bf Example 0} - branch history]
* d3c8087 (example0/branchB) Adding green peas
| * 4f281f2 (example0/branchA) Adding red tide
|/  
* f44c861 Get a phrase from a color
\end{lstlisting}

Dado que las líneas fueron agregadas en posiciones {\it diferentes} (separadas por la línea que define el color blanco), entonces
git no tiene ningún problema en mezclarlas:

\begin{lstlisting}[style=console_style, caption={\bf Ejemplo 0} - salida de {\bf git merge}]
$ git merge example0/branchB --no-edit
Auto-merging example.py
Merge made by the 'recursive' strategy.
 example.py | 1 +
 1 file changed, 1 insertion(+)
\end{lstlisting}

La historia resultante se ve así: \footnote{Si intenta hacer la mezcla por su lado y el ID de la revisión resultante no es la misma,
eso no es un problema. Es algo de esperar. Lo mismo sudecerá con todos los ejemplos que siguen si intentan hacerlas por su cuenta.}

\begin{lstlisting}[style=branch_history_style, caption={\bf Ejemplo 0} - historia final de las ramas]
*   74a049b Merge branch 'example0/branchB' into example0/branchA
|\  
| * d3c8087 (example0/branchB) Adding green peas
* | 4f281f2 Adding red tide
|/  
* f44c861 Get a phrase from a color
\end{lstlisting}

El archivo resultante se ve así:
\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 0} - código mezclado]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "green": "green peas",
          "white": "white noise",
          "red": "red tide",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

Y se puede ver que el archivo resultante tiene ambos colores rojo y verde:
\begin{lstlisting}[style=code_section_style, firstnumber=5, caption={\bf Ejemplo 0} - sección de los colores]
colors = {"black": "black mirror", <-- Linea preexistente
          "green": "green peas",   <-- Linea del Desarrollador B
          "white": "white noise",  <-- Linea preexistente
          "red": "red tide",       <-- Linea del Desarrollador A
          "blue": "blue sky"}      <-- Linea preexistente
\end{lstlisting}

Esto también se puede ver se se ven las anotaciones del archivo:\footnote{las anotaciones se pueden ver con
{\bf git annotate} o con {\bf git blame}}

% FIXME get output that is smaller, the date could be removed
\begin{lstlisting}[style=console_style, basicstyle=\small, caption={\bf Ejemplo 0} - anotaciones]
^f44c861 (Developer A 1584200950 -0600  5) colors = {"black": "black mirror",
d3c80878 (Developer B 1584201394 -0600  6)           "green": "green peas",
^f44c861 (Developer A 1584200950 -0600  7)           "white": "white noise",
4f281f22 (Developer A 1584201248 -0600  8)           "red": "red tide",
^f44c861 (Developer A 1584200950 -0600  9)           "blue": "blue sky"}
\end{lstlisting}

Y ahí tenemos una mezcla exitosa. Git fue capaz de hacer la mezcla porque se modifican secciones diferentes del
archivo. Git puede ver que las dos secciones están separadas por una línea que define la frase del color blanco
y por eso la mezcla se puede hacer.

Vamos de nuevo a nuestro ancestro común y mostremos 2 ejemplos de conflictos.
\subsection{Ejemplo 1 - Un conflicto sencillo}
\label{example_01}

Primero (de nuevo), {\bf el ancestro común}, que es el ancestro común que utilizamos en el \hyperref[example_00]{ejemplo 0}.
\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 1} - ancestro común]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

Ahora, como hicimos anteriormente, hagamos que nuestros 2 desarrolladores agreguen exactamente los mismos colores del
ejemplo anterior pero, en vez de hacerlo sobre sitios diferentes, que lo hagan exactamente en la misma posición.

El {\bf Desarrollador A} arega el color rojo en la línea 7:
\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 1} - Desarrollador A]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
          "red": "red tide",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

El {\bf Desarrollador B} agrega el color verde {\it también} en la línea 7:
\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 1} - Desarrollador B]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
          "green": "green peas",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

La nueva historia de las ramas se ve así:
\begin{lstlisting}[style=branch_history_style, caption={\bf Ejemplo 1} - historia de las ramas]
* 6e7707e (example1/branchB) Adding green peas
| * 3633ec9 (HEAD -> example1/branchA) Adding red tide
|/  
* 9f086a6 Get a phrase from a color
\end{lstlisting}

Es básicamente el mismo ejemplo solo que los colores fueron agregados en la misma línea.Si alguien le pidiera a git
que mezcle ambas ramas, se debería ver algo bastante diferente de lo que se vio en el \hyperref[example_00]{ejemplo 0}:

\begin{lstlisting}[style=console_style, caption={\bf Ejemplo 1} - salida de {\bf git merge}]
$ git merge example1/branchB
Auto-merging example.py
CONFLICT (content): Merge conflict in example.py
Automatic merge failed; fix conflicts and then commit the result
\end{lstlisting}

El estado del {\bf árbol de trabajo} en este momento:
\begin{lstlisting}[style=console_style, caption={\bf Ejemplo 1} - git status]
$ git status
On branch example1/branchA
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both modified:   example.py

no changes added to commit (use "git add" and/or "git commit -a")
\end{lstlisting}

Se puede ver que {\bf example.py} está listado en la sección llamada {\bf Unmerged paths} (rutas no mezcladas). Eso nos dice que
es el tipo de conflicto donde las dos ramas modificaron un archivo en direcciones {\it en conflicto} y que han producido un
{\bf Conflicto de Contenido}.\footnote{Los conflictos normalmente son de contenido, sin embargo hay otro tipo de conflictos,
{\bf conflictos de árbol}, de los que hablaremos más adelante}

El archivo resultante se vería así:
\footnote{No comiencen a quejarse porque no estoy usando \hyperref[diff3]{diff3}. Tengan calma, eso viene {\bf muy pronto}}
\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 1} - archivo en conflicto]
||||||| 30e1283
The resulting file would look something like this:
\begin{lstlisting}[style=python_style, caption={\bf example 1} - conflicting file]
=======
The resulting file would look something like this:
\footnote{Do not start complaining because we are not using \hyperref[diff3]{diff3}. Take it easy, it is coming {\bf very} soon.}
\begin{lstlisting}[style=python_style, caption={\bf example 1} - conflicting file]
>>>>>>> main
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
<<<<<<< HEAD
          "red": "red tide",
=======
          "green": "green peas",
>>>>>>> example1/branchB
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

Git trató lo mejor que pudo de resolver qué había que hacer y, dado que las dos ramas hacen cosas diferentes en el
mismopunto, git nos pide que le echemos una mano para que el código sea mezclado.

La sección de conflicto, como se pueden imaginar, es:
\begin{lstlisting}[style=python_style, firstline=7, firstnumber=7, lastline=11, caption={\bf Ejemplo 1} - Sección en conflicto]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
<<<<<<< HEAD
          "red": "red tide",
=======
          "green": "green peas",
>>>>>>> example1/branchB
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

El conflicto tiene 2 {\it secciones}. La primera seccion es como se ve el código en {\bf HEAD}.
\footnote{En el argot de git, {\bf HEAD} es siempre la revisión sobre la que se está trabajando. Es muy importante entender
que esto no es lo mismo que la úĺtima revisión de un repo, o la última revisión de una rama. Si se hace un checkout de
{\bf main~5}, se colocará {\bf HEAD} 5 revisiones detrás de la punta de la rama {\bf main}.}, y se puede ver {\bf HEAD} en la
marca de comienzo de conflicto, en la línea 7.

\begin{lstlisting}[style=python_style, firstline=7, firstnumber=7, lastline=9, caption={\bf Ejemplo 1} - sección de {\bf HEAD}]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
<<<<<<< HEAD <-- marca de inicio de conflicto
          "red": "red tide",
======= <-- separador entre HEAD y la otra rama
          "green": "green peas",
>>>>>>> example1/branchB
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

La segunda sección es como se ve el código de la sección del conflicto en {\bf la otra rama} que pedimos mezclar. Git
nos indica que el nombre de la otra rama es {\bf example1/branchA} en la marca de cierre el conflicto, en la línea 11:

\begin{lstlisting}[style=python_style, firstline=9, firstnumber=9, lastline=11, caption={\bf Ejemplo 1} - sección de {\bf la otra rama}]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
<<<<<<< HEAD
          "red": "red tide",
======= <-- separador entre HEAD y la otra rama
          "green": "green peas",
>>>>>>> example1/branchB <-- marca de final de conflicto
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

Las 2 secciones están separadas por una serie de signos de igual.

% TODO talk about that the only thing that can be assured is that only the previous line to the conflict... and the
% line following the conflict are in all 3 revisions. Everythng else might have been already modified by the (still to
% be completed merge)

La pregunta clave que tendríamos que responder en este punto es: {\it podemos resolver este conflicto?}
Probalemente estén pensado {\bf pero por supuesto!} Solo agregamos la línea del color nuev de cada rama para que todos
los colores queden en el diccionario.

\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 1} - conflicto resuelto]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
          "red": "red tide",
          "green": "green peas",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

Felicitaciones! Ya resolveron su {\it primer} (cierto?) conflicto. Los siguientes pasos son requeridos por git para poder
terminar con la operación de mezcla.

\subsection{Como finalizar un conflicto?}
% TODO try to run the merge --continue and see how it fails, then explain

Si en este punto corriéramos {\bf git status}, verían que nada ha cambiado aún, desde el punto de vista de git:

\begin{lstlisting}[style=console_style, caption={\bf git status} luego de editar el archivo]
$ git status
On branch example1/branchA
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)

Unmerged paths:
  (use "git add <file>..." to mark resolution)
        both modified:   example.py

no changes added to commit (use "git add" and/or "git commit -a")
\end{lstlisting}

Git no le estuvo prestando atención al archivo. Necesitamos decirle a git que tome el archivo como está en este
momento y lo coloque en el {\it índice}

\begin{lstlisting}[style=console_style, caption={\bf git add; git status}]
$ git add example.py 
$ git status
On branch example1/branchA
All conflicts fixed but you are still merging.
  (use "git commit" to conclude merge)

Changes to be committed:
        modified:   example.py
\end{lstlisting}

Cuando todos los archivos estén mezclados/agregados al índice, una revisión se puede crear corriendo {\bf git merge --continue}.
Esto hará que continúe el flujo de creación de la revisión como si hiciéramos un {\bf git commit} con un editor de texto
donde colocaremos el comentario de la revisión, y al guardar y salir se creará la revisión finalmente. Aquí está como se
ve al correr el {\bf git merge --continue} y saliendo del editor de texto:
% TODO show how the editor looks
% FIXME tus is too wide
\begin{lstlisting}[style=console_style, caption={\bf git merge --continue}]
$ git merge --continue
[example1/branchA 03938ed] Merge branch 'example1/branchB' into example1/branchA
\end{lstlisting}

Finalmente obtenemos la nueva revisión:
% FIXME this is too wide
\begin{lstlisting}[style=console_style, caption={\bf Ejemplo 1} - historia final de las ramas]
*   03938ed (example1/branchA) Merge branch 'example1/branchB' into example1/branchA
|\  
| * 6e7707e (example1/branchB) Adding green peas
* | 3633ec9 Adding red tide
|/  
* 9f086a6 Get a phrase from a color
\end{lstlisting}

% TODO run the final script (example 1) so we can see that it works for both colors

\subsection{Ejemplo 2 - Otro ejemplo sencillo}
\label{example_02}

Intentemos otro ejemplo sencillo. Usando el mismo ancestro común de antes (teníamos 3 colores, cierto?),
ahora el {\bf Desarrollador A} nos presenta esto:
\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 2} - Desarrollador A]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    phrase = "%s: %s" % (color, phrase)
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

Esto es algo diferente. La frase de salida ahora contiene el color y la frase asociada, separados por {\bf :} (línea 11).
Si corremos el script con {\bf blue}, obtenemos:
\begin{lstlisting}[style=console_style, caption={\bf Ejemplo 2} - Ejecutando el script del Desarrollador A]
$ ./example.py blue
blue: blue sky
\end{lstlisting}

El {\bf Desarrollador B} termina con esto:
\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 2} - Desarrollador B]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    phrase = phrase.upper()
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

El {\bf Desarrollador B} está agregando una llamada a {\bf upper()} para colocar la frase en mayúsculas (linea 11). Si ejecutamos el
script como hicimos antes:
\begin{lstlisting}[style=console_style, caption={\bf Ejemplo 2} - ejecutando el script del Desarrollador B]
$ ./example.py blue
BLUE SKY
\end{lstlisting}

Y la historia se ve así:
\begin{lstlisting}[style=console_style, caption={\bf Ejemplo 2} - historia de las ramas]
* 9b9d7b2 (example2/branchB) Using upper on the phrase
| * c944ee5 (example2/branchA) Showing color and phrase
|/  
* 8c9d315 Get a phrase from a color
\end{lstlisting}

Y esta vez podemos predecir el conflicto que vamos a tener al intentar mezclar, cierto?
\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 2} - Archivo en conflicto]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
<<<<<<< HEAD
    phrase = "%s: %s" % (color, phrase)
=======
    phrase = phrase.upper()
>>>>>>> example2/branchB
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

En este caso retengamos la línea donde colocamos el color original en la frase, luego hacemos una llamada a {\bf upper()}
y eso sería todo:
\begin{lstlisting}[style=python_style, caption={\bf Ejemplo 2} - Conflicto resuelto]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white": "white noise",
          "blue": "blue sky"}

def getPhrase(color):
    phrase = colors[color]
    phrase = "%s: %s" % (color, phrase)
    phrase = phrase.upper()
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

Y si ejecutamos el script final:
\begin{lstlisting}[style=console_style, caption={\bf Ejemplo 2} - ejecutando el script final]
$ ./example.py blue
BLUE: BLUE SKY
\end{lstlisting}

\subsection{Preguntas}
Estas son algunas preguntas sobre las cuales pensar:

\subsubsection{P: Se podría colocar las líneas de forma inversa?}
Claro! Todo depende de lo que indiquen los requerimientos de cada rama y como se deben comportar en la revisión actual.
En el \hyperref[example_01]{ejemplo 1}, solo se trataba de agregar elementos a un diccionario así que no había diferencia
significativa si se colocaban las líneas de forma inversa. Si en ese ejemplo se colocaran los colores de forma alfabética,
entonces el orden si sería importante. En este ejemplo, si la llamada a {\bf upper()} se colocara {\it antes} de colocar
el color original en la frase, entonces las mayúsculas solo afectarían a la frase, no al color original. Eso es correcto?
Quizás! Considerar los {\bf requerimientos} (no solo el código en conflicto) podrían ser necesarios para saber qué hacer
en este caso.

\subsubsection{P: Se podría escribir de una forma completamente diferente?}
Por supuesto! Mientras las {\bf intenciones} de lo que quería hacer cada rama se incluyan en la resolución del conflicto,
estará bien.\footnote{De todos modos, jugar con el código mientras se resuelven conflictos tiene un precio. Hablaremos de ello
más adelante con más detalle.}

\subsubsection{P: Cómo se vería el conflicto si las ramas hubieran estado invertidas al mezclar?}
En el \hyperref[example_02]{ejemplo 2}, trabajando sobre {\bf example2/branchB}, trato de mezclar {\bf example2/branchA}.
Cual sería el resultado?
Se vería {\bf exactamente igual} solo que en la sección en conflicto, las secciones de cada rama estarían invertidas
 y el nombre de la rama en la marca de cierre de conflicto sería otra:

\begin{lstlisting}[style=python_style, firstnumber=11, caption={\bf ejemplo 2} - conflicto invertido]
<<<<<<< HEAD
    phrase = phrase.upper()
=======
    phrase = "%s: %s" % (color, phrase)
>>>>>>> example2/branchA
\end{lstlisting}

\subsection{Ejercicios}
\subsubsection{Ejercicio 1}
Tome la rama {\bf exercise1/branchA } del \hyperref[exercises_repo]{\bf repositorio de ejercicios}. Hay una lista
e verbos irregulares en inglés dentro de {\bf irregular.txt} en orden alfabético. Agregue estos dos verbos: {\bf drink} y {\bf know}.
Luego tome {\bf example1/branchB } y agregue estos dos verbos: {\bf lose } y {\bf keep }. Mezcle ambas ramas. La solución está
\hyperref[exercise_01]{aquí}. \footnote{ Quien dice que no se puede practicar inglés mientras se programa? }

\subsubsection{Ejercicio 2}
Del \hyperref[exercises_repo]{\bf repositorio de ejercicios}, mezcle las ramas {\bf exercise2/branchA} y {\bf exercise2/branchB}.
La solución está \hyperref[exercise_02]{aquí}.
