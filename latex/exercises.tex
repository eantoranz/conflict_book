% copyright 2020 Edmundo Carmona Antoranz
% Released under the terms of Creative Commons Attribution-ShareAlike 4.0 International Public License

\chapter{Exercises}

\section{Exercise 1}
\label{exercise_01}
\subsection*{Problem}
Take branch {\bf exercise1/branchA } from the \hyperref[exercises_repo]{\bf exercises repo}. There is a short list of
irregular verbs inside {\bf irregular.txt} in alphabetical order. Add these two verbs: {\bf drink} and {\bf know}. Then
take branch {\bf example1/branchB } and add these other 2 verbs: {\bf lose } and {\bf keep }. Merge the two branches.

\subsection*{Conflict}
You should see a conflict like this:
\begin{lstlisting}[style=console_style, numbers=left, caption={\bf Exercise 1} - conflict]
# List of irregular verbs
# simple form<tab>past tense<tab>past participle
catch	caught	caught
draw	drew	drawn
drink	drank	drinken
eat	ate	eaten
fight	fought	fought
fly	flew	flown
grow	grew	grown
hang	hung	hung
<<<<<<< HEAD
know	knew	known
=======
keep	kept	kept
>>>>>>> exercise1/branchB
let	let	let
lose	lost	lost
read	read	read
run	ran	run
sleep	slept	slept
\end{lstlisting}

You might have gotten the conflct section branches in reverse order (first {\bf keep}, then {\bf know}) if you were on {\bf branchB} 
and then tried to merge {\bf branchA}. Notice how the conflict is only related to {\bf know/keep}. The other two verbs,
{\bf drink} and {\bf lose}, were merged correctly, even though they come from different branches.

\subsection*{Resolution}
Given that the verbs are ordered alphabetically, the resulting file looks like this:
\begin{lstlisting}[style=console_style, numbers=left, caption={\bf Exercise 1} - Resolution]
# List of irregular verbs
# simple form<tab>past tense<tab>past participle
catch	caught	caught
draw	drew	drawn
drink	drank	drinken
eat	ate	eaten
fight	fought	fought
fly	flew	flown
grow	grew	grown
hang	hung	hung
keep	kept	kept
know	knew	known
let	let	let
lose	lost	lost
read	read	read
run	ran	run
sleep	slept	slept
\end{lstlisting}
Given that the list is sorted alphabetically, {\bf keep} had to be placed before {\bf know}.


\section{Exercise 2}
\label{exercise_02}
From the \hyperref[exercises_repo]{\bf exercises repo}, merge branches {\bf exercise2/branchA} and {\bf exercise2/branchB}.

\subsection*{Conflict}
\begin{lstlisting}[style=python_style, caption={\bf Exercise 2} - conflict]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white":  "white noise",
          "blue": "blue sky"}

def getPhrase(color):
<<<<<<< HEAD
    phrase = colors[color.lower()]
=======
    if color not in colors:
        sys.stderr.write("Got no phrase for color %s\n" % color)
        sys.exit(1)
    phrase = colors[color]
>>>>>>> exercise2/branchB
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

\subsection*{Resolution}
Correct resolution {\bf might} be something like this:

\begin{lstlisting}[style=python_style, caption={\bf Exercise 2} - resolution]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white":  "white noise",
          "blue": "blue sky"}

def getPhrase(color):
    if color.lower() not in colors:
        sys.stderr.write("Got no phrase for color %s\n" % color)
        sys.exit(1)
    phrase = colors[color.lower()]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

If you didn't use the {\bf lower()} call on line 10, it's ok... for the time being. I will explain the rationale to
add that call later on. You could have done other things like save color to be lowercase before going into the {\bf if} on
line 10 but we will be touching on the things that we could/should do as we go through other topics. Rest assured, this is just a {\bf teaser} of a conflict.

\section{Exercise 3}
\label{exercise_03}
From \hyperref[git_repo]{git's repo}, checkout revision {\bf fe870600fe} and merge {\bf 1bdca81641}
\footnote{These are the parents of revision {\bf f8cb64e3d4}}. Solve both conflicts (there are 2 conflicting files,
one conflict section on each one of the files).

\subsection*{Conflict in path.c}
\begin{lstlisting}[style=c_style, firstnumber=852, caption={\bf Exercise 3} - conflict in {\bf path.c}]
	if (is_git_directory(".")) {
<<<<<<< HEAD
		set_git_dir(".", 0);
		check_repository_format();
||||||| 51ebf55b93
		set_git_dir(".");
		check_repository_format();
=======
		set_git_dir(".");
		check_repository_format(NULL);
>>>>>>> 1bdca81641
		return path;
	}
\end{lstlisting}
I don't think it is too difficult to realize what happened on each branch. On {\bf HEAD} the call to {\bf set\_git\_dir()} got a second
parameter on line 854. On {\bf the other branch}, the call to {\bf check\_repository\_format()} got a new NULL parameter on line 861.
That points to having this as the conflict resolution:

\begin{lstlisting}[style=c_style, firstnumber=852, caption={\bf Exercise 3} - resolution to conflict in {\bf path.c}]
	if (is_git_directory(".")) {
		set_git_dir(".", 0);
		check_repository_format(NULL);
		return path;
	}
\end{lstlisting}

\subsection*{Conflict in builtin/pack-objects.c}
\begin{lstlisting}[style=c_style, basicstyle=\small, firstnumber=880, caption={\bf Exercise 3} - conflict in {\bf builtin/pack-objects.c}]
	len = encode_in_pack_object_header(header, sizeof(header),
					   OBJ_REF_DELTA, size);
	hashwrite(out, header, len);
<<<<<<< HEAD
	hashwrite(out, base_oid.hash, 20);
||||||| 51ebf55b93
	hashwrite(out, base_sha1, 20);
=======
	hashwrite(out, base_sha1, the_hash_algo->rawsz);
>>>>>>> 1bdca81641
	copy_pack_data(out, reuse_packfile, w_curs, cur, next - cur);
	return;
\end{lstlisting}

In this case, on {\bf HEAD} the second parameter to the {\bf hashwrite()} call was changed from {\bf base\_sha1} on
line 886 to {\bf base\_oid.hash} on line 884. On {\bf the ther branch}, the {\it third parameter} to the same call was
changed from {\bf 20} on line 886 to {\bf the\_hash\_algo-$>$rawsz} on line 888. This all points to this as the conflict
resolution:

\begin{lstlisting}[style=c_style, firstnumber=880, basicstyle=\small, caption={\bf Exercise 3} - conflict in {\bf builtin/pack-objects.c}]
	len = encode_in_pack_object_header(header, sizeof(header),
					   OBJ_REF_DELTA, size);
	hashwrite(out, header, len);
	hashwrite(out, base_oid.hash, the_hash_algo->rawsz);
	copy_pack_data(out, reuse_packfile, w_curs, cur, next - cur);
	return;
\end{lstlisting}

If you compare with revision {\bf f8cb64e3d4}, you should get no meaningful difference.

As an {\bf additional} exercise, imagine what the task would have been {\it if} {\bf diff3} had not been used.

\section{Exercise 4 - a git conflict}
\label{exercise_04}
From \hyperref[git_repo]{git's repo}, checkout {\bf d9d65e9f6a} and merge {\bf b57e8119e6}.
\footnote{These are the parents of revision {\bf 01f8d78887}}.

\subsection*{CB in contrib/completion/git-completion.bash}
\begin{lstlisting}[style=c_style,
	firstnumber=2614,
	basicstyle=\tiny,
	caption={\bf Exercise 4} - CB in {\bf contrib/completion/git-completion.bash}]
<<<<<<< HEAD
	local subcommands="add status init deinit update summary foreach sync absorbgitdirs"
||||||| d62dad7a7d
	local subcommands="add status init deinit update summary foreach sync"
=======
	local subcommands="add status init deinit update set-branch summary foreach sync"
>>>>>>> b57e8119e6
\end{lstlisting}

\subsection*{Working from {\bf UB} (keeping markers for clarity)}
\begin{lstlisting}[style=c_style,
	firstnumber=2614,
	basicstyle=\tiny,
	caption={\bf Exercise 4} - UB in {\bf contrib/completion/git-completion.bash}]
<<<<<<< HEAD
	local subcommands="add status init deinit update summary foreach sync absorbgitdirs"
||||||| d62dad7a7d
\end{lstlisting}

\subsection*{Get {\bf dML}}
\begin{lstlisting}[style=c_style,
	firstnumber=2616,
	basicstyle=\tiny,
	caption={\bf Exercise 4} - {\bf MB} and {\bf LB} in {\bf contrib/completion/git-completion.bash}]
||||||| d62dad7a7d
	local subcommands="add status init deinit update summary foreach sync"
=======
	local subcommands="add status init deinit update set-branch summary foreach sync"
>>>>>>> b57e8119e6
\end{lstlisting}

{\bf dML}: {\bf set-branch} is added between {\bf update} and {\bf summary} as a {\bf subcommand}.

\subsection*{Apply {\bf dML} on {\bf UB}}
\begin{lstlisting}[style=c_style,
	firstnumber=2614,
	basicstyle=\tiny,
	caption={\bf Exercise 4} - UB in {\bf contrib/completion/git-completion.bash}]
<<<<<<< HEAD
	local subcommands="add status init deinit update set-branch summary foreach sync absorbgitdirs"
||||||| d62dad7a7d
\end{lstlisting}

\subsection*{Result}
\begin{lstlisting}[style=c_style,
	firstnumber=2610,
	basicstyle=\tiny,
	caption={\bf Exercise 4} - Conflict Resolution]
_git_submodule ()
{
	__git_has_doubledash && return

	local subcommands="add status init deinit update set-branch summary foreach sync absorbgitdirs"
	local subcommand="$(__git_find_on_cmdline "$subcommands")"
\end{lstlisting}


\section{Exercise 5 - another git conflict}
\label{exercise_05}
From \hyperref[git_repo]{git's repo}, checkout revision {\bf cf054f817a} and merge revision {\bf caf388caa1}.
\footnote{These are the parents of revision {\bf 9b6606f43d}}.

I will let you work on this conflict on your own. There are 5 CBs in 3 files. When you are done, compare
with {\bf 9b6606f43d} and you should get no meaningful differences.

\section{Exercise 6}
\label{exercise_06}

From \hyperref[git_repo]{git repo}, checkout revision {\bf 0194c9ad72} and merge revision {\bf aa46a0da30}. There will be
a {\bf CB} in {\bf ref-filter.c}:

\begin{lstlisting}[style=c_style,
	firstnumber=843,
	caption={\bf Exercise 6} - {\bf CB} in {\bf ref-filter.c}]
<<<<<<< HEAD
/*
 * Given an object name, read the object data and size, and return a
 * "struct object".  If the object data we are returning is also borrowed
 * by the "struct object" representation, set *eaten as well---it is a
 * signal from parse_object_buffer to us not to free the buffer.
 */
static void *get_obj(const struct object_id *oid, struct object **obj, unsigned long *sz, int *eaten)
{
	enum object_type type;
	void *buf = read_object_file(oid, &type, sz);

	if (buf)
		*obj = parse_object_buffer(the_repository, oid, type, *sz,
					   buf, eaten);
	else
		*obj = NULL;
	return buf;
}

||||||| e3331758f1
/*
 * Given an object name, read the object data and size, and return a
 * "struct object".  If the object data we are returning is also borrowed
 * by the "struct object" representation, set *eaten as well---it is a
 * signal from parse_object_buffer to us not to free the buffer.
 */
static void *get_obj(const struct object_id *oid, struct object **obj, unsigned long *sz, int *eaten)
{
	enum object_type type;
	void *buf = read_object_file(oid, &type, sz);

	if (buf)
		*obj = parse_object_buffer(oid, type, *sz, buf, eaten);
	else
		*obj = NULL;
	return buf;
}

=======
>>>>>>> aa46a0da30
\end{lstlisting}

It's a conflict ouf of deleted code.

\subsubsection{dMU}
Modified the call to {\bf parse\_object\_buffer()} to have {\bf the\_repository} as the first argument on line 856.

\subsubsection{dML}
Deleted the whole section of code.

\subsubsection{Resolution}
Should we delete the whole {\bf CB} and move on with our lives? I really hope you had a Pavlov reflex saying {\bf NOOOOO!!!!!}
Good! All the hard work is paying off. We need to find out what happened with that code. The hard way is to find out
in what revision that code was deleted to see if it was moved. First, we do the {\bf git blame --reverse}:

\begin{lstlisting}[style=console_style,
	caption={\bf Exercise 6} - {\bf git blame --reverse} on {\bf ref-filter.c}]
.
.
.
04f6ee1a58e  807)       if (buf)
04f6ee1a58e  808)               *obj = parse_object_buffer(oid, type, *sz, buf, eaten);
04f6ee1a58e  809)       else
04f6ee1a58e  810)               *obj = NULL;
\end{lstlisting}

The last revision when the line was {\bf present} was on {\bf 04f6ee1a58e}. Let's check what follows that revision:
\begin{lstlisting}[style=console_style,
	caption={\bf Exercise 6} - {\bf git log --oneline} on {\bf ref-filter.c}]
$ git log --oneline --graph 04f6ee1a58e..aa46a0da30 -- ref-filter.c
* aa46a0da30 ref-filter: use oid_object_info() to get object
* e2255179f6 ref-filter: merge get_obj and get_object
\end{lstlisting}

And checking those two revisions we find that the code was {\it apparently} {\bf deleted} in {\bf e2255179f6}.

\begin{lstlisting}[style=c_style,
	firstnumber=843,
	caption={\bf Exercise 6} - {\bf git show e2255179f6}]
$ git show e2255179f6 --pretty=
diff --git a/ref-filter.c b/ref-filter.c
index 8db7ca95b1..2b401a17c4 100644
--- a/ref-filter.c
+++ b/ref-filter.c
@@ -797,24 +797,6 @@ int verify_ref_format(struct ref_format *format)
        return 0;
 }
 
-/*
- * Given an object name, read the object data and size, and return a
- * "struct object".  If the object data we are returning is also borrowed
- * by the "struct object" representation, set *eaten as well---it is a
- * signal from parse_object_buffer to us not to free the buffer.
- */
-static void *get_obj(const struct object_id *oid, struct object **obj, unsigned long *sz, int *eaten)
-{
-       enum object_type type;
-       void *buf = read_object_file(oid, &type, sz);
-
-       if (buf)
-               *obj = parse_object_buffer(oid, type, *sz, buf, eaten);
-       else
-               *obj = NULL;
-       return buf;
-}
-
 static int grab_objectname(const char *name, const struct object_id *oid,
                           struct atom_value *v, struct used_atom *atom)
 {
@@ -1437,21 +1419,25 @@ static const char *get_refname(struct used_atom *atom, struct ref_array_item *re
 }
 
 static int get_object(struct ref_array_item *ref, const struct object_id *oid,
-                      int deref, struct object **obj, struct strbuf *err)
+                     int deref, struct object **obj, struct strbuf *err)
 {
        /* parse_object_buffer() will set eaten to 0 if free() will be needed */
        int eaten = 1;
        int ret = 0;
        unsigned long size;
-       void *buf = get_obj(oid, obj, &size, &eaten);
+       enum object_type type;
+       void *buf = read_object_file(oid, &type, &size);
        if (!buf)
                ret = strbuf_addf_ret(err, -1, _("missing object %s for %s"),
                                      oid_to_hex(oid), ref->refname);
-       else if (!*obj)
-               ret = strbuf_addf_ret(err, -1, _("parse_object_buffer failed on %s for %s"),
-                                     oid_to_hex(oid), ref->refname);
-       else
-               grab_values(ref->value, deref, *obj, buf, size);
+       else {
+               *obj = parse_object_buffer(oid, type, size, buf, &eaten);
+               if (!*obj)
+                       ret = strbuf_addf_ret(err, -1, _("parse_object_buffer failed on %s for %s"),
+                                             oid_to_hex(oid), ref->refname);
+               else
+                       grab_values(ref->value, deref, *obj, buf, size);
+       }
        if (!eaten)
                free(buf);
        return ret;
\end{lstlisting}

In the second {\bf hunk} we can see that the call to {\bf parse\_object\_buffer} was {\bf added} back. In other words,
the call was {\bf moved}, and that call is {\it still} in our conflicted file, in line 1520:
\begin{lstlisting}[style=c_style,
	firstnumber=1519,
	caption={\bf Exercise 6} - section of {\bf ref-filter.c}]
	if (oi->info.contentp) {
		*obj = parse_object_buffer(&oi->oid, oi->type, oi->size, oi->content, &eaten);
		if (!obj) {
			if (!eaten)
				free(oi->content);
			return strbuf_addf_ret(err, -1, _("parse_object_buffer failed on %s for %s"),
					       oid_to_hex(&oi->oid), ref->refname);
		}
		grab_values(ref->value, deref, *obj, oi->content, oi->size);
	}
\end{lstlisting}

So all we need to do, as our {\bf dMU} requests, is to add {\bf the\_repository} as the first argument
to the call on line 1520:
\begin{lstlisting}[style=c_style,
	firstnumber=1519,
	caption={\bf Exercise 6} - adjusted section of {\bf ref-filter.c}]
	if (oi->info.contentp) {
		*obj = parse_object_buffer(the_repository, &oi->oid, oi->type, oi->size, oi->content, &eaten);
		if (!obj) {
			if (!eaten)
				free(oi->content);
			return strbuf_addf_ret(err, -1, _("parse_object_buffer failed on %s for %s"),
					       oid_to_hex(&oi->oid), ref->refname);
		}
		grab_values(ref->value, deref, *obj, oi->content, oi->size);
	}
\end{lstlisting}

We remove the original {\bf CB}:
\begin{lstlisting}[style=c_style,
	firstnumber=840,
	caption={\bf Exercise 6} - remove {\bf CB} in {\bf ref-filter.c}]
	return 0;
}

static int grab_objectname(const char *name, const struct object_id *oid,
			   struct atom_value *v, struct used_atom *atom)
{
\end{lstlisting}

And if you now check differences with revision {\bf c83149ace6}, you should get none.

