% copyright 2020 Edmundo Carmona Antoranz
% Released under the terms of Creative Commons Attribution-ShareAlike 4.0 International Public License

\chapter{Ejercicios}

\section{Ejercicio 1}
\label{exercise_01}
\subsection*{Problema}
Tome la rama {\bf exercise1/branchA } del \hyperref[exercises_repo]{\bf repositorio de ejercicios}. Hay una lista
e verbos irregulares en inglés dentro de {\bf irregular.txt} en orden alfabético. Agregue estos dos verbos: {\bf drink} y {\bf know}.
Luego tome {\bf example1/branchB } y agregue estos dos verbos: {\bf lose } y {\bf keep }. Mezcle ambas ramas.

\subsection*{Conflicto}
Se debe ver un conflicto así:
\begin{lstlisting}[style=console_style, numbers=left, caption={\bf Ejercicio 1} - conflicto]
# List of irregular verbs
# simple form<tab>past tense<tab>past participle
catch	caught	caught
draw	drew	drawn
drink	drank	drinken
eat	ate	eaten
fight	fought	fought
fly	flew	flown
grow	grew	grown
hang	hung	hung
<<<<<<< HEAD
know	knew	known
=======
keep	kept	kept
>>>>>>> exercise1/branchB
let	let	let
lose	lost	lost
read	read	read
run	ran	run
sleep	slept	slept
\end{lstlisting}

Puede ser que las secciones del conflicto estén en orden inverso (primero {\bf keep} y luego {\bf know}) si estaban en la rama
{\bf branchB} e intentaron mezclar la rama {\bf branchA}. Fíjense que el conflicto sol se refiere a {\bf keep/know}. Los otros dos verbos,
{\bf drink} y {\bf lose}, se mezclaron correctamente, unque vienen de ramas diferentes.

\subsection*{Resolución}
Dado que los verbos se están agregando en orden alfabético, el archivo resultante se debe ver así:
\begin{lstlisting}[style=console_style, numbers=left, caption={\bf Ejercicio 1} - Resolución]
# List of irregular verbs
# simple form<tab>past tense<tab>past participle
catch	caught	caught
draw	drew	drawn
drink	drank	drinken
eat	ate	eaten
fight	fought	fought
fly	flew	flown
grow	grew	grown
hang	hung	hung
keep	kept	kept
know	knew	known
let	let	let
lose	lost	lost
read	read	read
run	ran	run
sleep	slept	slept
\end{lstlisting}
Dado que la lista es alfabética, se debe colocar {\bf keep} seguido de {\bf know}.


\section{Ejercicio 2}
\label{exercise_02}
Del \hyperref[exercises_repo]{\bf repositorio de ejercicios}, mezcle las ramas {\bf exercise2/branchA} y {\bf exercise2/branchB}.

\subsection*{Conflicto}
\begin{lstlisting}[style=python_style, caption={\bf Ejercicio 2} - conflicto]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white":  "white noise",
          "blue": "blue sky"}

def getPhrase(color):
<<<<<<< HEAD
    phrase = colors[color.lower()]
=======
    if color not in colors:
        sys.stderr.write("Got no phrase for color %s\n" % color)
        sys.exit(1)
    phrase = colors[color]
>>>>>>> exercise2/branchB
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

\subsection*{Resolution}
La solución correcta debe ser algo así:

\begin{lstlisting}[style=python_style, caption={\bf Ejercicio 2} - resolución]
#!/usr/bin/python

import sys

colors = {"black": "black mirror",
          "white":  "white noise",
          "blue": "blue sky"}

def getPhrase(color):
    if color.lower() not in colors:
        sys.stderr.write("Got no phrase for color %s\n" % color)
        sys.exit(1)
    phrase = colors[color.lower()]
    return phrase

print(getPhrase(sys.argv[1]))
\end{lstlisting}

Si no colocaron la llamada a {\bf lower()} en la línea 10, está bien... por el momento. Explicaré la lógica
para agregar la llamada más adelante. Pudieron haber hecho otras cosas como guardar el color para que quede en minúsculas antes
de entrar al {\bf if} de la línea 10 pero veremos las cosas que se podría/debería hacer a medida que avanzamos en otros tópicos.
Puedo asegurarles algo, esto es solo un abrebocas de lo que es un conflicto.

\section{Ejercicio 3}
\label{exercise_03}
\subsubsection{Ejercicio 3}
Del \hyperref[git_repo]{repo de git}, hacer checkout de la revisión {\bf fe870600fe} y mezclar {\bf 1bdca81641}
\footnote{Estos son los padres de la revisión {\bf f8cb64e3d4}}. Resuelvan ambos conflictos (hay 2 archivos con conflctos,
un conflicto en cada archivo).

\subsection*{Conflicto en path.c}
\begin{lstlisting}[style=c_style, firstnumber=852, caption={\bf Ejercicio 3} - conflicto en {\bf path.c}]
	if (is_git_directory(".")) {
<<<<<<< HEAD
		set_git_dir(".", 0);
		check_repository_format();
||||||| 51ebf55b93
		set_git_dir(".");
		check_repository_format();
=======
		set_git_dir(".");
		check_repository_format(NULL);
>>>>>>> 1bdca81641
		return path;
	}
\end{lstlisting}
Creo que noes muy difícil entender lo que sucedió en cada rama. En {\bf HEAD} la llamada a {\bf set\_git\_dir()}
toma un segundo parámetro en la línea 854. En {\bf la otra rama}, la llamada a {\bf check\_repository\_format()} tiene un
nuevo parámetro {\bf NULL} en la línea 861. Esto apunta a tener esto como resolución del conflicto:

\begin{lstlisting}[style=c_style, firstnumber=852, caption={\bf Ejercicio 3} - resolución del conflicto en {\bf path.c}]
	if (is_git_directory(".")) {
		set_git_dir(".", 0);
		check_repository_format(NULL);
		return path;
	}
\end{lstlisting}

\subsection*{Conflicto en builtin/pack-objects.c}
\begin{lstlisting}[style=c_style, basicstyle=\small, firstnumber=880, caption={\bf Ejercicio 3} - conflicto en {\bf builtin/pack-objects.c}]
	len = encode_in_pack_object_header(header, sizeof(header),
					   OBJ_REF_DELTA, size);
	hashwrite(out, header, len);
<<<<<<< HEAD
	hashwrite(out, base_oid.hash, 20);
||||||| 51ebf55b93
	hashwrite(out, base_sha1, 20);
=======
	hashwrite(out, base_sha1, the_hash_algo->rawsz);
>>>>>>> 1bdca81641
	copy_pack_data(out, reuse_packfile, w_curs, cur, next - cur);
	return;
\end{lstlisting}

En este caso, en {\bf HEAD} el {\it segundo parámetro} a la llamada a {\bf hashwrite()} fue cambiado de {\bf base\_sha1} en
la línea 886 a {\bf base\_oid.hash} en la línea 884. En {\bf la otra rama}, el {\it tercer parámetro} a la misma llamada
cambió de {\bf 20} en la línea 886 a {\bf the\_hash\_algo-$>$rawsz} en la línea 888. Esto apunta a esto como resolución:

\begin{lstlisting}[style=c_style, firstnumber=880, basicstyle=\small, caption={\bf Ejercicio 3} - resolución del conflicto en {\bf builtin/pack-objects.c}]
	len = encode_in_pack_object_header(header, sizeof(header),
					   OBJ_REF_DELTA, size);
	hashwrite(out, header, len);
	hashwrite(out, base_oid.hash, the_hash_algo->rawsz);
	copy_pack_data(out, reuse_packfile, w_curs, cur, next - cur);
	return;
\end{lstlisting}

Si comparan con la revisión {\bf f8cb64e3d4}, ne deberían obtener diferencias significativas.

Como ejercicio {\bf adicional},  imaginen lo que tendrían que hacer para resolver esos conflictos si no usaran {\bf diff3}.

\section{Ejercicio 4 - un conflicto de git}
\label{exercise_04}
Del \hyperref[git_repo]{repo de git}, hagan checkout de la revisión {\bf d9d65e9f6a} y hagan {\it merge} de {\bf b57e8119e6}
\footnote{Estos son los padres de la revisión {\bf 01f8d78887}}.

\subsection*{CB en contrib/completion/git-completion.bash}
\begin{lstlisting}[style=c_style,
	firstnumber=2614,
	basicstyle=\tiny,
	caption={\bf Ejercicio 4} - CB en {\bf contrib/completion/git-completion.bash}]
<<<<<<< HEAD
	local subcommands="add status init deinit update summary foreach sync absorbgitdirs"
||||||| d62dad7a7d
	local subcommands="add status init deinit update summary foreach sync"
=======
	local subcommands="add status init deinit update set-branch summary foreach sync"
>>>>>>> b57e8119e6
\end{lstlisting}

\subsection*{Trabajando en el {\bf UB} (mantenemos los marcadores por claridad)}
\begin{lstlisting}[style=c_style,
	firstnumber=2614,
	basicstyle=\tiny,
	caption={\bf Ejercicio 4} - UB en {\bf contrib/completion/git-completion.bash}]
<<<<<<< HEAD
	local subcommands="add status init deinit update summary foreach sync absorbgitdirs"
||||||| d62dad7a7d
\end{lstlisting}

\subsection*{Analizar {\bf dML}}
\begin{lstlisting}[style=c_style,
	firstnumber=2616,
	basicstyle=\tiny,
	caption={\bf Ejercicio 4} - {\bf MB} y {\bf LB} en {\bf contrib/completion/git-completion.bash}]
||||||| d62dad7a7d
	local subcommands="add status init deinit update summary foreach sync"
=======
	local subcommands="add status init deinit update set-branch summary foreach sync"
>>>>>>> b57e8119e6
\end{lstlisting}

{\bf dML}: se agrega {\bf set-branch} entre {\bf update} y {\bf summary} como un nuevo {\bf subcomando}.

\subsection*{Aplicar {\bf dML} en el {\bf UB}}
\begin{lstlisting}[style=c_style,
	firstnumber=2614,
	basicstyle=\tiny,
	caption={\bf Ejercicio 4} - UB en {\bf contrib/completion/git-completion.bash}]
<<<<<<< HEAD
	local subcommands="add status init deinit update set-branch summary foreach sync absorbgitdirs"
||||||| d62dad7a7d
\end{lstlisting}

\subsection*{Resultado}
\begin{lstlisting}[style=c_style,
	firstnumber=2610,
	basicstyle=\tiny,
	caption={\bf Ejercicio 4} - Resolución de conflicto]
_git_submodule ()
{
	__git_has_doubledash && return

	local subcommands="add status init deinit update set-branch summary foreach sync absorbgitdirs"
	local subcommand="$(__git_find_on_cmdline "$subcommands")"
\end{lstlisting}


\section{Ejercicio 5 - otro conflicto en git}
\label{exercise_05}
Del \hyperref[git_repo]{repo de git}, hagan checkout de la revisión {\bf cf054f817a} y hagan {\it merge} de {\bf caf388caa1}.
\footnote{Estos son los padres de la revisión {\bf 9b6606f43d}}

Dejaré que trabajen en la solución por su cuenta. Hay 5 {\bf CBs} en 3 archivos. Cuando terminen, comparen
con {\bf 9b6606f43d} y no deberían tener diferencias significativas.

\section{Ejercicio 6}
\label{exercise_06}

Del \hyperref[git_repo]{repo de git}, hagan checkout de la revisión {\bf 0194c9ad72} y hagan un merge de {\bf aa46a0da30}.
Van a ver un {\bf CB} en {\bf ref-filter.c}:

\begin{lstlisting}[style=c_style,
	firstnumber=843,
	caption={\bf Ejercico 6} - {\bf CB} en {\bf ref-filter.c}]
<<<<<<< HEAD
/*
 * Given an object name, read the object data and size, and return a
 * "struct object".  If the object data we are returning is also borrowed
 * by the "struct object" representation, set *eaten as well---it is a
 * signal from parse_object_buffer to us not to free the buffer.
 */
static void *get_obj(const struct object_id *oid, struct object **obj, unsigned long *sz, int *eaten)
{
	enum object_type type;
	void *buf = read_object_file(oid, &type, sz);

	if (buf)
		*obj = parse_object_buffer(the_repository, oid, type, *sz,
					   buf, eaten);
	else
		*obj = NULL;
	return buf;
}

||||||| e3331758f1
/*
 * Given an object name, read the object data and size, and return a
 * "struct object".  If the object data we are returning is also borrowed
 * by the "struct object" representation, set *eaten as well---it is a
 * signal from parse_object_buffer to us not to free the buffer.
 */
static void *get_obj(const struct object_id *oid, struct object **obj, unsigned long *sz, int *eaten)
{
	enum object_type type;
	void *buf = read_object_file(oid, &type, sz);

	if (buf)
		*obj = parse_object_buffer(oid, type, *sz, buf, eaten);
	else
		*obj = NULL;
	return buf;
}

=======
>>>>>>> aa46a0da30
\end{lstlisting}

Es un conflicto por código borrado.

\subsubsection{dMU}
Se modificó la llamada a {\bf parse\_object\_buffer()} para que el primer argumento sea {\bf the\_repository} en la línea 856.

\subsubsection{dML}
Se borró toda la sección de código.

\subsubsection{Resolución}
Deberíamos borrar todo el {\bf CB} y seguir adelante con nuestras vidas? Espero que hayan tenid un rejlejo de Pavlov diciendo
{\bf NOOOOO!!!!!}. Excelente! Todo ese trabajo duro está dando frutos. Debemos averiguar qué pasó con ese código. La forma
dura es averiguar en qué revision se borró el código para ver si fue movido. Primero hacemos el {\bf git blame --reverse}:

\begin{lstlisting}[style=console_style,
	caption={\bf Ejercicio 6} - {\bf git blame --reverse} en {\bf ref-filter.c}]
.
.
.
04f6ee1a58e  807)       if (buf)
04f6ee1a58e  808)               *obj = parse_object_buffer(oid, type, *sz, buf, eaten);
04f6ee1a58e  809)       else
04f6ee1a58e  810)               *obj = NULL;
\end{lstlisting}

La última revisión en la cual la línea estuvo {\bf presente} fue en {\bf 04f6ee1a58e}. Vemos qué sigue a esa revisión:
\begin{lstlisting}[style=console_style,
	caption={\bf Ejercicio 6} - {\bf git log --oneline} en {\bf ref-filter.c}]
$ git log --oneline --graph 04f6ee1a58e..aa46a0da30 -- ref-filter.c
* aa46a0da30 ref-filter: use oid_object_info() to get object
* e2255179f6 ref-filter: merge get_obj and get_object
\end{lstlisting}

Y al verificar esas dos revisions vemos queel código fue {\it aparentemente} {\bf borrado} en {\bf e2255179f6}:

\begin{lstlisting}[style=c_style,
	firstnumber=843,
	caption={\bf Ejercicio 6} - {\bf git show e2255179f6}]
$ git show e2255179f6 --pretty=
diff --git a/ref-filter.c b/ref-filter.c
index 8db7ca95b1..2b401a17c4 100644
--- a/ref-filter.c
+++ b/ref-filter.c
@@ -797,24 +797,6 @@ int verify_ref_format(struct ref_format *format)
        return 0;
 }
 
-/*
- * Given an object name, read the object data and size, and return a
- * "struct object".  If the object data we are returning is also borrowed
- * by the "struct object" representation, set *eaten as well---it is a
- * signal from parse_object_buffer to us not to free the buffer.
- */
-static void *get_obj(const struct object_id *oid, struct object **obj, unsigned long *sz, int *eaten)
-{
-       enum object_type type;
-       void *buf = read_object_file(oid, &type, sz);
-
-       if (buf)
-               *obj = parse_object_buffer(oid, type, *sz, buf, eaten);
-       else
-               *obj = NULL;
-       return buf;
-}
-
 static int grab_objectname(const char *name, const struct object_id *oid,
                           struct atom_value *v, struct used_atom *atom)
 {
@@ -1437,21 +1419,25 @@ static const char *get_refname(struct used_atom *atom, struct ref_array_item *re
 }
 
 static int get_object(struct ref_array_item *ref, const struct object_id *oid,
-                      int deref, struct object **obj, struct strbuf *err)
+                     int deref, struct object **obj, struct strbuf *err)
 {
        /* parse_object_buffer() will set eaten to 0 if free() will be needed */
        int eaten = 1;
        int ret = 0;
        unsigned long size;
-       void *buf = get_obj(oid, obj, &size, &eaten);
+       enum object_type type;
+       void *buf = read_object_file(oid, &type, &size);
        if (!buf)
                ret = strbuf_addf_ret(err, -1, _("missing object %s for %s"),
                                      oid_to_hex(oid), ref->refname);
-       else if (!*obj)
-               ret = strbuf_addf_ret(err, -1, _("parse_object_buffer failed on %s for %s"),
-                                     oid_to_hex(oid), ref->refname);
-       else
-               grab_values(ref->value, deref, *obj, buf, size);
+       else {
+               *obj = parse_object_buffer(oid, type, size, buf, &eaten);
+               if (!*obj)
+                       ret = strbuf_addf_ret(err, -1, _("parse_object_buffer failed on %s for %s"),
+                                             oid_to_hex(oid), ref->refname);
+               else
+                       grab_values(ref->value, deref, *obj, buf, size);
+       }
        if (!eaten)
                free(buf);
        return ret;
\end{lstlisting}

Pero en el segundo {\bf hunk} se puede ver que la llamada a {\bf parse\_object\_buffer} fue {\bf agregada} de nuevo. En otras
palabras, la llamada fue {\bf movida}, y esa llamada sigue en nuestro archivo, en la línea 1520:
\begin{lstlisting}[style=c_style,
	firstnumber=1519,
	caption={\bf Ejercicio 6} - sección de {\bf ref-filter.c}]
	if (oi->info.contentp) {
		*obj = parse_object_buffer(&oi->oid, oi->type, oi->size, oi->content, &eaten);
		if (!obj) {
			if (!eaten)
				free(oi->content);
			return strbuf_addf_ret(err, -1, _("parse_object_buffer failed on %s for %s"),
					       oid_to_hex(&oi->oid), ref->refname);
		}
		grab_values(ref->value, deref, *obj, oi->content, oi->size);
	}
\end{lstlisting}

Así que todo loque debemos hacer, como nos lo quiere el {\bf dMU}, es agregar {\bf the\_repository}
como primer argumento a la llamada e la línea 1520:
\begin{lstlisting}[style=c_style,
	firstnumber=1519,
	caption={\bf Ejercicio 6} - Sección ajustada de {\bf ref-filter.c}]
	if (oi->info.contentp) {
		*obj = parse_object_buffer(the_repository, &oi->oid, oi->type, oi->size, oi->content, &eaten);
		if (!obj) {
			if (!eaten)
				free(oi->content);
			return strbuf_addf_ret(err, -1, _("parse_object_buffer failed on %s for %s"),
					       oid_to_hex(&oi->oid), ref->refname);
		}
		grab_values(ref->value, deref, *obj, oi->content, oi->size);
	}
\end{lstlisting}

Se remuele el {\bf CB} original:
\begin{lstlisting}[style=c_style,
	firstnumber=840,
	caption={\bf Ejercicio 6} - {\bf CB} removido en {\bf ref-filter.c}]
	return 0;
}

static int grab_objectname(const char *name, const struct object_id *oid,
			   struct atom_value *v, struct used_atom *atom)
{
\end{lstlisting}

Y si verifican las diferencias con la revisión {\bf c83149ace6}, no deberían obtener ninguna.

